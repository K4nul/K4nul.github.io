---
layout: single
title: "[RTF] 문서형 악성코드 분석"
categories: Malware
tag: [Malware,rtf,cve 2018-0798,EQNEDT]
author_profile: false
sidebar:
    nav: "docs"
search: false
---



# 악성코드 정보
    파일 타입: Doc
	해시 값: ffc735ea518844e8fb5276905b5368a23f9953ee18c235c51aebf9553dc2974f
    파일 크기: 95,210 Byte



# 분석 개요

이 악성코드는 doc 확장자를 가지고 있지만 내부 데이터를 살펴보면 

rtf(Rich Text Format) 형식의 문서 파일이다.

EQNEDT32.EXE 파일의 취약점을 이용해 악성 행위를 한다. 

이 악성코드에서 사용한 취약점은 cve 2018-0798로 

개체가 메모리에서 처리되는 방식으로 인해서 발생하는 취약점

# 정적 분석

악성코드를 정적으로 분석하기 위해 rtfobj와 rtfdump를 통해 내부를 살펴보았다. 

![images]({{site.url}}/images/rtf-malware/1.png)

rtfobj를 통해 이 악성코드에 대한 특별한 정보는 얻을 수 없었다. 

하지만 rtfdump.py [파일명] 명령어를 통해 정보를 얻어내었다. 

![images]({{site.url}}/images/rtf-malware/2.png)

rtf 포맷에서 악성 행위를 분석하기 위해서는 objdata를 분석해야 한다. 

상세한 분석을 하기 위해 내부를 확인해 본다

![images]({{site.url}}/images/rtf-malware/3.png)

rtfdump.py [파일명] -s 4 명령어를 통해 다음과 같은 특이한 형태의 

데이터를 얻을 수 있었고 이것을 아스키 값으로 변환해보겠다 

![images]({{site.url}}/images/rtf-malware/4.png)

방금 명령어에서 -H를 추가하면 다음과 같이 아스키로 변환된 데이터를 확인할 수 있다. 

대부분은 알 수 없는 데이터이지만 한가지 우리가 읽을 수 있는 데이터가 존재한다 

**eQuaTIon.3** 

이 문자열은 rtf 내부에서 데이터를 인식하는 문자열이다 

equation.3은 rtf파일에 수식편집기 객체를 포함한다는 의미이다. 

rtf 파일은 내부에 OLE 객체를 포함할 수 있는데 이때 파일의 형식을 통해서  

파일을 인식하는 것이 아니라 위 사진과 같이  


Class Name을 통해 인식을 한다.

그 뒤 알수 없는 데이터가 존재하는데 rtf파일은 ms에서 정한 구조가 존재하며 

이 구조를 바탕으로 분석을 시작한다. 

    3B B9 BD 5C(4byte) : OLE version 

    02 00 00 00(4byte) : Format ID 

    0B 00 00 00(4byte) : Class Name Length

    65 51 75 61 54 49 4F 6E 2E 33(Nbyte): Class Name eQuaTIon.3

    00 00 00 00(4byte): Topic Name

    00 00 00 00(4byte): Item Length 

    C6 05 00 00(4byte): Data Size 

중요한 부분만 요약하면 

Class Name Length를 바탕으로 Class Name의 길이가 정해진다. 

Data Size를 통해 바로 뒤에 나오는 데이터의 크기가 결정된다. 

여기 까지 분석을 해서 알아낸 것을 정리해 보자 

    1. EQNEDT32.EXE를 사용한다 
    2. 그 이후 알 수 없는 데이터를 포함하고 있다. 
    3. rtf 파일을 실행하면 EQNEDT32가 실행되면서 알수 없는 데이터를 Load 한다

별로 알아낸 것이 없다...

그럼 이제부터 실제로 실행해서 정체를 알 수 없는 데이터에 대해서 알아내야 한다. 


# 동적 분석

지금까지 알아낸 정보를 통해 문서를 열어보면서 분석을 시작한다. 

문서를 실행시키면 EQNEDT32가 동시에 실행된다. 

이 EQNEDT가 동작할 때 Load되는 데이터가 어떤건지 찾아보도록 한다.

![images]({{site.url}}/images/rtf-malware/5.png)

이 함수 이후로 스택에 변화가 생긴 것을 확인하였으며 

이후 ret을 통해 알 수 없는 주소로 이동하는 것을 확인하였다. 

이 함수 내부에서 어떤 동작을 수행하는지 확인해 보았다. 

내부에서 역시 하나의 함수를 통해 스택에 변경이 이루어지는 것을 확인했으며

이 함수가 취약점을 유발하는 함수라는 것을 알 수 있었다.

![images]({{site.url}}/images/rtf-malware/6.png)

이 함수에서 반복문을 사용하여 스택에 데이터를 쓰는 것을 확인하였다. 

내부의 반복문은 다음과 같은 구조로 되어있으며 

call을 통해 스택에 1바이트씩 데이터를 write하고 있었다. 

![images]({{site.url}}/images/rtf-malware/11.png)

이 반복문 이전 스택의 모습은 아래 사진과 같이 깨끗한 상태였다. 

![images]({{site.url}}/images/rtf-malware/7.png)

하지만 반복문 이후의 스택은 아래 사진과 같이 메모리가 침범되어있는 상태가 되었다. 

![images]({{site.url}}/images/rtf-malware/8.png)

중요한 것은 침범했다는 것 보다 함수가 ret 될때 주소값이 변경되었다는 점이다. 

이제 함수를 벗어나 ret을 만나 이동하는 주소로 가면 알 수 없는 주소로 이동하였다. 

계속 이동하면 알 수 없는 주소로 이동한다. 

![images]({{site.url}}/images/rtf-malware/9.png)

이 주소의 정체는 rtf내에서 OLE 객체 정보를 담고 있는 주소로 

명령어 바이너리 값을 확인해 보면

익숙한 데이터라는 것을 알 수 있다. 

![images]({{site.url}}/images/rtf-malware/10.png)

다음과 같이 정적분석했을 때 보았던 정체를 알 수 없는 

데이터였으며 이 데이터가 쉘코드라는 것을 알 수 있다. 

# 결론 

이 악성코드는 rtf 포맷 내부에 쉘코드를 포함하고 있다. 

rtf 내부의 OLE 객체의 데이터를 EQNEDT32.EXE가 로드하며 

이때 메모리에서 처리되는 방식으로 인해 취약점이 유발된다.









